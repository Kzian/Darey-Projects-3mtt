# CI/CD Project: From Zero to Heroku (with Tests, Workflows, and Real-World Fixes)

- This document walks through **everything** done in this project — from first setup to a fully working CI/CD pipeline that runs **tests** and **deploys automatically to Heroku**. It also includes **every error emcountered** and **how they were fixed**.

- ### The repo can be visited via this link: 

[cicd_git_actions](https://github.com/Kzian/cicd_git_actions)

---

## 0) Prerequisites

- **Node.js 20.x** (we standardize on Node 20 everywhere to avoid version mismatches)
- **Git + GitHub** repository
- **Heroku** account and app (created via dashboard)
- **Heroku API Key** stored as a **GitHub Secret**

> Why Node 20? We use **Express 5**, and it relies on `Object.hasOwn` — a feature only available in Node 15+. Running on old Node versions leads to hard-to-read crashes (see Errors section).

---

## 1) Project Setup

**Folder structure**

```
cicd_git_actions/
├── index.js
├── package.json
├── package-lock.json        (generated by npm install)
├── test/
│   └── test.js
└── .github/
    └── workflows/
        ├── deploy.yml
        └── node.js.yml
```

**.gitignore** (to avoid committing OS noise and `node_modules/`):
```gitignore
# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
*.log

# Builds
dist/
build/
out/
tmp/

# Env
.env
.env.*

# OS / Editor
.DS_Store
Thumbs.db
.vscode/
.idea/
```

**package.json** (final good version)
```json
{
  "name": "cicd_git_actions",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "npx mocha"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "engines": {
    "node": "20.x"
  },
  "dependencies": {
    "express": "^5.1.0"
  },
  "devDependencies": {
    "mocha": "^11.7.1",
    "supertest": "^7.1.4"
  }
}
```

Install deps locally (this **generates** `package-lock.json`):
```bash
rm -rf node_modules package-lock.json
npm install
```

---

## 2) Application Code

**index.js**
```js
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

app.get('/', (req, res) => {
  res.send('Hello World!');
});

// Health for monitoring
app.get('/health', (_req, res) => {
  res.json({ status: 'ok' });
});

// Example "integration" endpoint
app.get('/time', (_req, res) => {
  res.json({ now: new Date().toISOString() });
});

if (require.main === module) {
  app.listen(port, () => {
    console.log(`App listening at http://localhost:${port}`);
  });
}

module.exports = app; // export for testing
```

---

## 3) Tests (Unit + Integration)

**test/test.js**
```js
const request = require('supertest');
const assert = require('assert');
const app = require('../index');

describe('GET /', () => {
  it('should return Hello World!', async () => {
    const res = await request(app).get('/');
    assert.strictEqual(res.statusCode, 200);
    assert.strictEqual(res.text, 'Hello World!');
  });
});

describe('GET /health', () => {
  it('should return ok status', async () => {
    const res = await request(app).get('/health');
    assert.strictEqual(res.statusCode, 200);
    assert.deepStrictEqual(res.body, { status: 'ok' });
  });
});

describe('GET /time', () => {
  it('should return current time', async () => {
    const res = await request(app).get('/time');
    assert.strictEqual(res.statusCode, 200);
    assert.ok(res.body.now);
  });
});

// Example "unit" style test (non-HTTP)
describe('Math helper', () => {
  function add(a, b) { return a + b; }
  it('should correctly add numbers', () => {
    assert.strictEqual(add(2, 3), 5);
  });
});
```

Run locally:
```bash
npm test
```

---

## 4) GitHub Actions — Continuous Integration (CI)

We keep a **CI workflow** that runs tests on every push and pull request.

**.github/workflows/node.js.yml**
```yaml
name: Node.js CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [20.x]    # Use modern Node to match Express 5

    steps:
      - uses: actions/checkout@v3

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          check-latest: true

      - name: Verify Node.js version
        run: |
          which node
          node -v
          npm -v

      - run: npm install
      - run: npm run build --if-present
      - run: npm test
```

> Earlier, we had a matrix including Node 14 and 16; that caused `Object.hasOwn` crashes with Express 5. We removed old versions to stabilize CI.

---

## 5) Heroku Deployment — Continuous Deployment (CD)

### A) Prepare Heroku
1. Create the app in the Heroku dashboard (we used the UI since CLI asked for card details).
2. Collect secrets for GitHub:
   - `HEROKU_API_KEY`
   - `HEROKU_APP_NAME` (e.g., `cicd-demo-app`)
   - `HEROKU_EMAIL` (your Heroku account email)
3. Add these under **GitHub repo → Settings → Secrets and variables → Actions → New repository secret**.

> Heroku needs a `start` script and uses `PORT` from env. Our `index.js` and `package.json` already handle this.

### B) Deployment Workflow
**.github/workflows/deploy.yml**
```yaml
name: Deploy to Heroku

on:
  push:
    branches:
      - main

concurrency:
  group: heroku-deploy
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Unshallow the repo for Heroku push
      run: git fetch --unshallow

    - name: Set up Node.js 20
      uses: actions/setup-node@v3
      with:
        node-version: '20'
        check-latest: true

    - name: Verify Node.js version
      run: |
        which node
        node -v
        npm -v

    - name: Install dependencies
      run: npm install

    - name: Run tests
      run: npm test

    - name: Deploy to Heroku
      env:
        HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
        HEROKU_APP_NAME: ${{ secrets.HEROKU_APP_NAME }}
        HEROKU_EMAIL: ${{ secrets.HEROKU_EMAIL }}
      run: |
        curl https://cli-assets.heroku.com/install.sh | sh
        heroku git:remote -a $HEROKU_APP_NAME
        git config --global user.email "$HEROKU_EMAIL"
        git config --global user.name "GitHub Actions"
        git push https://heroku:$HEROKU_API_KEY@git.heroku.com/$HEROKU_APP_NAME.git HEAD:main --force
```

> The **Unshallow** step fixes Heroku’s error about shallow clones during `git push`.  
> We **verify Node** so logs prove we’re actually on Node 20 (prevents the Express 5 crash).

---

## 6) Experiment & Learn (What to Try)

- **Break a test on purpose** → CI fails → no deploy → fix and push → CI passes → deploys.
- **Add manual approval** before production deploy:
  - GitHub → Settings → Environments → `production` → Required reviewers.
  - In deploy job add `environment: production`.
- **Matrix test** (CI only) with Node 18 + 20:
  ```yaml
  matrix:
    node-version: [18.x, 20.x]
  ```
- **Add coverage**:
  ```bash
  npm i -D nyc
  ```
  `package.json`:
  ```json
  "scripts": {
    "test": "nyc npx mocha"
  }
  ```

---

## 7) Troubleshooting Diary (Errors Hit & Fixes)

### Error 1 — `Object.hasOwn is not a function`
**When running tests in CI:**  
```
TypeError: Object.hasOwn is not a function
  at express/lib/express.js ...
```
**Cause:** Express 5 uses `Object.hasOwn`, available only in Node 15+. CI ran Node 14/16.  
**Fix:** Force Node 20 in both workflows and in `package.json` engines. Alternatively, downgrade to `express@4` if you must run on Node 14.

---

### Error 2 — `npm ci` → `Cannot read property 'express' of undefined`
**In GitHub Actions:**  
```
npm ERR! Cannot read property 'express' of undefined
```
**Cause:** `npm ci` needs a clean, matching `package-lock.json`. It was missing/corrupted.  
**Fixes:**
- Switch to `npm install` **or**
- Regenerate a fresh `package-lock.json` locally, commit it, and then use `npm ci`.

---

### Error 3 — `mocha: Permission denied`
**In CI (Linux):**  
```
sh: 1: mocha: Permission denied
```
**Cause:** `node_modules/` had Windows ACLs committed to Git.  
**Fix:** Add `node_modules/` to `.gitignore`, remove it from the repo (`git rm -r --cached node_modules`), then let CI reinstall.

---

### Error 4 — Global Mocha confusion
**Locally (Windows):**  
```
Error: Cannot find module 'C:\mocha\bin\mocha.js'
```
**Cause:** A globally installed Mocha confused resolution.  
**Fix:** Uninstall global Mocha and use a local devDependency:
```bash
npm uninstall -g mocha
npm i -D mocha
npm test     # uses npx mocha from local node_modules
```

---

### Error 5 — Windows path / .bin not recognized
**Locally (Windows):**
```
'...node_modules\.bin\' is not recognized as an internal or external command
```
**Cause:** Calling tools via platform-specific `.bin` paths.  
**Fix:** Use `npm scripts` or `npx mocha` (cross‑platform).

---

### Error 6 — Heroku push rejected (shallow clone)
**In the deploy step:**
```
Push rejected, source repository is a shallow clone.
Unshallow it with `git fetch --all --unshallow` and try again.
```
**Fix:** Add **Unshallow** step in workflow:
```yaml
- run: git fetch --unshallow
```

---

### Heads‑up — VS Code shows `${{ secrets.* }}` warnings in YAML
**Symptom:** yellow squiggle “context access might be invalid”.  
**Context:** VS Code can’t validate GitHub runtime expressions statically.  
**Fix:** Ignore locally; they resolve correctly during GitHub Actions runtime.

---

### Heads‑up — Heroku “Application Error” page
**Common causes:**
- Missing `"start"` script
- Not listening on `process.env.PORT`
- Wrong Node version (no `engines`)
- Failing build or missing dependencies
**Fix:** Ensure:
- `scripts.start = "node index.js"`
- `const port = process.env.PORT || 3000;`
- `"engines": { "node": "20.x" }`
- Check logs: `heroku logs -t -a <app>`

---

## 8) Verification

After a successful run:  
- CI logs show:
  - Node `v20.x.x`
  - Tests **passing**
- Deployment logs show:
  - Heroku CLI installed
  - `git push` to `heroku` succeeded
- Browser/CLI checks:
  ```bash
  curl -i https://<HEROKU_APP_NAME>.herokuapp.com/
  curl -s https://<HEROKU_APP_NAME>.herokuapp.com/health
  ```

---

## 9) Final Checklist

- [x] `index.js` with `/`, `/health`, `/time`
- [x] `test/test.js` with unit + integration tests
- [x] `.gitignore` ignores `node_modules/`
- [x] `package.json` has `"start"`, `"test"`, and `"engines": { "node": "20.x" }`
- [x] CI workflow (`node.js.yml`) uses Node 20 and runs tests
- [x] Deploy workflow (`deploy.yml`) runs tests then deploys to Heroku
- [x] GitHub secrets: `HEROKU_API_KEY`, `HEROKU_APP_NAME`, `HEROKU_EMAIL`
- [x] Heroku app opens in browser successfully

---

## 10) What was learnt

- How to design a minimal Node/Express app for CI/CD
- How to write unit and integration tests with Mocha + Supertest
- How to configure **two** GitHub Actions workflows (CI + Deploy)
- How to surface and fix real-world issues:
  - Node version mismatches (Express 5)
  - `npm ci` vs `npm install` + lockfiles
  - Windows/Linux path and permissions
  - Heroku shallow clone rejection
- How to make your pipeline reproducible and safe

---

**Live app:** `https://<HEROKU_APP_NAME>.herokuapp.com/`  
**Health check:** `https://<HEROKU_APP_NAME>.herokuapp.com/health`

> Replace `<HEROKU_APP_NAME>` with your actual app name (e.g., `cicd-demo-app`).

---

### IMAGES

![1](img/clone.png)

![2](img/commit.png)

![3](img/deploy.png)

![4](img/deploy2.png)

![5](img/done.png)

![6](img/gitactions.png)

![7](img/gitadd.png)

![8](img/gitdeploy.png)

![9](img/gitnode.png)

![10](img/heroku.png)

![11](img/heroku1.png)

![12](img/herokuapi.png)

![13](img/index.png)

![14](img/installsupertest.png)

![15](img/newrepo.png)

![16](img/node.png)

![17](img/pkgjson.png)

![18](img/proc.png)

![19](img/pushworkflow.png)

![20](img/test.png)

![21](img/testingtest.png)

![22](img/testingtest2.png)

![23](img/workflow.png)

![24](img/workflow1.png)

![25](img/herokucred.png)







